1.
I/O本來擁有一塊自己的記憶體空間，
需透過特殊的CPU指令存取I/O裝置。
Memory Mapped I/O 是指I/O與memory共用記憶體空間，
將I/O的port或memory mapping到記憶體位址上，
存取I/O裝置時就像操作一般的記憶體讀取，
透過一般指令即可。

2.
DMA是一個記憶體存取技術，
它允許某些電腦中的硬體可以直接讀寫記憶體，
而不需經由CPU的參與。

當硬體需要傳輸大量資料時，
透過DMA controller向CPU發出DMA需求 (要求記憶體Bus控制權)。
CPU將資料來源地址、目的地地址、資料長度寫入記憶體中，
然後將這些資訊位址轉交給DMA controller。
接下來由DMA controller接手進行傳輸資料。
等完成資料傳輸後，DMA controller會對CPU發出interrupt。

3.
(a)
FCFS：
      0                8  9   11 12           18
      |----------------|--|----|--|------------|
      |       P1       |P2| P3 |P4|     P5     |  

SJF：
     
      0  1  2    4           10               18
      |--|--|----|------------|----------------|
      |P2|P4| P3 |     P5     |        P1      | 

Priority：
    
      0  1            7    9               17 18  
      |--|------------|----|----------------|--|
      |P2|     P5     | P3 |       P1       |P4|  
      
RR：
      
      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
      |--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
      |P1|P2|P3|P4|P5|P1|P3|P5|P1|P5|P1|P5|P1|P5|P1|P5|P1|P1|   
      
      
(b)
              | FCFS | SJF | Priority |  RR  
      --------|------|-----|----------|------
         P1   |   8  |  18 |    17    |  18  
         P2   |   9  |   1 |     1    |   2 
         P3   |  11  |   4 |     9    |   7   
         P4   |  12  |   2 |    18    |   4
         P5   |  18  |  10 |     7    |  16 
      --------|------|-----|----------|------
      Average | 11.6 |  7  |  10.4    |  9.4

(c)
              | FCFS | SJF | Priority |  RR  
      --------|------|-----|----------|------
         P1   |   0  |  10 |     9    |   10   
         P2   |   8  |   0 |     0    |   1  
         P3   |   9  |   2 |     7    |   5 
         P4   |  11  |   1 |    17    |   3  
         P5   |  12  |   4 |     1    |   10   
      --------|------|-----|----------|------
      Total   |  40  |  17 |    34    |   29

(d) SJF has the minimal average waiting time.

4.
subroutine.
subroutine像是我們一般寫程式執行到某個函式時，主程式會先跳到函式執行，
執行完後再跳回main，才會繼續執行下去。
而coroutine像是thread，允許函式執行到一半就中斷，中斷時內部狀態及狀態會被保留下來，
之後可以再恢復這個 coroutine。
我們一般寫程式的時候都是在user part，當我們需要比較高的權限，
例如system call，就會進到kernel part，等到做完再回到user part，
這樣比較符合subroutine。
